# Mini Assignment 2: Large Code Bases and OOP
## Fibonacci 
*https://github.com/llvm/llvm-project/tree/main/llvm/examples/Fibonacci*
**Description:** This small program provides an example of how to build quickly a small module with function Fibonacci and execute it with the JIT.The goal of this snippet is to create in the memory the LLVM module
// consisting of one function as follow:
**User Defined Data Types Used:**
Function , FunctionType , BasicBlock , Value , Argument , CallInst , LLVMContext , GenericValue

**Basic C++ Data Types Used:**
std::unique_ptr , std::string ,   std::vector
* Line 49:
```c++
using namespace llvm;
```
Name space is a feature added to C++ and not present in C and is used to to identify which function to call in case multiple functions of the same name are present in the header file. Declaring this statement at the start of the code ensures that the programmer does't have to write **llvm::** before every function that uses this scope.

* Line 51
```c++
static Function *CreateFibFunction(Module *M, LLVMContext &Context)
```
Declaring a function before main, one of the ways a function can be declared. The return type is static Function* , Function being an user defined data type. 

* Line 68
```c++
ArgX->setName("AnArg");  
```
ArgX is a pointer variable to a class object and **->** is being used to access public function of the class. These functions can be accessed by creating a instance of the class that points to the same memory location using pointer and then call the function on that instance using the **.** operator.

* Line 76
```c++
Value *CondInst = new ICmpInst(*BB, ICmpInst::ICMP_SLE, ArgX, Two, "cond");
```
new is a basic c++ feature that is used to allocate memory. While calling new parameter may be passed according to the constructor one may like to call to allocate space to as well as initialize the parameters contained in the class object.

* Line 99
```c++
return FibF;
```
return is used here to give back the value indicated after return. Return is also used to return control from the function back to the point where it was called (usually main). In case of a void function the end bracket serves the purpose but it may be coded somwhere in between in order to return control if certain condition is satisfied

* Line 102
```c++
int main(int argc, char **argv) {
```
argc and argv are arguments passed with main and used to directly take paramters when giving command to run the executable instead of prompting user for an input after the code starts running. 

* Line 110
```c++
std::unique_ptr<Module> Owner(new Module("test", Context));
```
std::unique_ptr is a data type that was introduced in C++11 and is used to create a pointer whose value cannot be copied. This helps the program to better claim the resources back as when this pointer is destroyed so is the object associated with it.

* Line 135-137
```c++
  errs() << "OK\n";
  errs() << "We just constructed this LLVM module:\n\n---------\n" << *M;
  errs() << "---------\nstarting fibonacci(" << n << ") with JIT...\n";
 ```
 errs is a user defined function and it is taking input using the **<<** operator using a overloaded **<<** operator which returns reference back to the *ostream* object
* Line 140
```c++
std::vector<GenericValue> Args(1);
```
Declaring a vector of type GenericValue
